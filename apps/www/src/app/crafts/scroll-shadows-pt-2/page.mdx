import { Alert } from "~/components/crafts/alert";
import { ComparisonTable } from "~/components/crafts/comparison-table";
import {
  InteractiveVerticalDemo,
  InteractiveHorizontalDemo,
  CSSVariablesDemo,
  ComparisonDemo,
} from "./examples/demos";

# Scroll Shadows (Pt. 2)

<time className="-mt-6 mb-8 block text-gray-400">December 10, 2025</time>

In [Part 1](/crafts/scroll-shadows), we built scroll shadows using Framer Motion's `useScroll` hook. It worked great, but required JavaScript to animate the shadow opacity on every scroll event.

What if we could move that animation logic to CSS?

<InteractiveVerticalDemo caption="Scroll the content and toggle shadows to see the effect." />

In this follow-up, we'll use [Base UI's ScrollArea](https://base-ui.com/react/components/scroll-area) component, which exposes CSS custom properties that track scroll position. We'll use these to create shadows that animate entirely in CSS.

## The Trade-offs

Before diving in, let's be clear about what we're trading:

<ComparisonTable
  headers={["Part 1 (Framer Motion)", "Part 2 (Base UI)"]}
  rows={[
    ["~30kb dependency", "~15kb dependency"],
    ["Opacity-based fade (smooth)", "Height-based visibility"],
    ["Manual overflow detection", "Built-in"],
    ["MotionValue (outside React)", "CSS custom properties"],
  ]}
/>

We haven't eliminated JavaScript — Base UI still tracks scroll position. We've just moved the _animation_ from JS to CSS.

## How Base UI Tracks Scroll

Base UI's `ScrollArea.Viewport` exposes four CSS custom properties that update as you scroll:

- `--scroll-area-overflow-y-start` — pixels scrolled from top
- `--scroll-area-overflow-y-end` — pixels remaining to bottom
- `--scroll-area-overflow-x-start` — pixels scrolled from left
- `--scroll-area-overflow-x-end` — pixels remaining to right

<CSSVariablesDemo caption="Scroll to see the CSS variable values update in real-time." />

Under the hood, Base UI attaches an `onScroll` handler that computes these values:

```tsx
// Simplified from Base UI's source
const scrollTop = viewportEl.scrollTop;
const maxScrollTop = viewportEl.scrollHeight - viewportEl.clientHeight;

viewportEl.style.setProperty(
  "--scroll-area-overflow-y-start",
  `${scrollTop}px`
);
viewportEl.style.setProperty(
  "--scroll-area-overflow-y-end",
  `${maxScrollTop - scrollTop}px`
);
```

Compare this to our Part 1 approach:

```tsx
// Part 1: Framer Motion
const { scrollYProgress } = useScroll({ container: ref });
// Returns 0 at top, 1 at bottom — we used this to control opacity
```

The key difference: Framer Motion gives us a normalized value (0→1), while Base UI gives us pixels (0→maxScroll). This changes how we control the shadows.

## The CSS Trick

In Part 1, we animated shadow _opacity_ based on scroll progress. Here, we'll animate shadow _height_ using CSS `min()`:

```css
height: min(40px, var(--scroll-area-overflow-y-start, 0px));
```

This means:

- When `--scroll-area-overflow-y-start` is `0px` (at top), height is `0px` — shadow invisible
- As you scroll, height grows with the scroll offset
- Height caps at `40px` (our max shadow size)

The shadow literally grows from nothing as you scroll away from the edge.

<Alert variant="note">
Base UI uses `CSS.registerProperty()` to set `inherits: false` on these custom properties. This is a performance optimization — it prevents the browser from recalculating styles for the entire subtree on every scroll.

The catch: child elements won't see these values unless we explicitly set them to `inherit`.

</Alert>

## Building the Component

Install Base UI:

```zsh
npm install @base-ui/react
```

Here's the component structure. The shadows are sibling elements to the viewport, using `::before` and `::after` pseudo-elements:

```tsx
import { ScrollArea as ScrollAreaPrimitive } from "@base-ui/react/scroll-area";

function ScrollArea({ scrollShadow = "none", children, ...props }) {
  return (
    <ScrollAreaPrimitive.Root {...props}>
      <ScrollAreaPrimitive.Viewport>{children}</ScrollAreaPrimitive.Viewport>

      {/* Shadow overlay — positioned absolutely within Root */}
      <div
        className={cn(
          scrollShadow === "vertical" ? "block" : "hidden",
          "absolute inset-0 pointer-events-none",
          // Top shadow
          "before:absolute before:top-0 before:inset-x-0",
          "before:h-[min(40px,var(--scroll-area-overflow-y-start,0px))]",
          "before:bg-linear-to-b before:from-black/20 before:to-transparent",
          // Bottom shadow
          "after:absolute after:bottom-0 after:inset-x-0",
          "after:h-[min(40px,var(--scroll-area-overflow-y-end,0px))]",
          "after:bg-linear-to-t after:from-black/20 after:to-transparent"
        )}
        style={{
          "--scroll-area-overflow-y-start": "inherit",
          "--scroll-area-overflow-y-end": "inherit",
        }}
      />

      <ScrollAreaPrimitive.Scrollbar>
        <ScrollAreaPrimitive.Thumb />
      </ScrollAreaPrimitive.Scrollbar>
    </ScrollAreaPrimitive.Root>
  );
}
```

The `inherit` values are crucial — without them, the pseudo-elements won't see the CSS variables.

## Horizontal Shadows

The same pattern works for horizontal scrolling:

<InteractiveHorizontalDemo caption="Horizontal scroll shadows using the same technique." />

Just swap the axes:

```tsx
// Width instead of height
"before:w-[min(40px,var(--scroll-area-overflow-x-start,0px))]";
"after:w-[min(40px,var(--scroll-area-overflow-x-end,0px))]";

// Left/right instead of top/bottom
"before:left-0 before:inset-y-0";
"after:right-0 after:inset-y-0";

// Gradient direction
"before:bg-gradient-to-r";
"after:bg-gradient-to-l";
```

## Comparing the Approaches

<ComparisonDemo caption="Part 1 uses opacity fading, Part 2 uses height-based visibility." />

The visual difference is subtle but noticeable:

- **Part 1 (opacity)**: Shadow fades smoothly from 0% to 100% opacity as you scroll
- **Part 2 (height)**: Shadow grows from 0px to 40px, then stays at full opacity

Part 1 feels slightly more polished because the fade is proportional to scroll progress. Part 2 is simpler — the shadow is either growing or at full size.

<Alert variant="tip">
  You could add `transition: height 100ms` to smooth out the height changes, but
  it won't match the proportional fade of the Framer Motion approach.
</Alert>

## When to Use Each Approach

**Use Part 1 (Framer Motion) when:**

- You want smooth, proportional opacity fading
- You're already using Framer Motion in your project
- You need fine-grained control over the animation curve

**Use Part 2 (Base UI) when:**

- You want simpler code with animation logic in CSS
- You're already using Base UI or Radix
- You need built-in scrollbar components
- Bundle size is a concern (~15kb vs ~30kb)

## Final Code

```tsx
import { ScrollArea as ScrollAreaPrimitive } from "@base-ui/react/scroll-area";
import { cn } from "@/lib/utils";

interface ScrollAreaProps extends ScrollAreaPrimitive.Root.Props {
  scrollShadow?: "vertical" | "horizontal" | "both" | "none";
}

export function ScrollArea({
  className,
  scrollShadow = "none",
  children,
  ...props
}: ScrollAreaProps) {
  const showVertical = scrollShadow === "vertical" || scrollShadow === "both";
  const showHorizontal =
    scrollShadow === "horizontal" || scrollShadow === "both";

  return (
    <ScrollAreaPrimitive.Root className={cn("relative", className)} {...props}>
      <ScrollAreaPrimitive.Viewport className="size-full overscroll-contain">
        {children}
      </ScrollAreaPrimitive.Viewport>

      {/* Vertical shadows */}
      {showVertical && (
        <div
          className={cn(
            "absolute inset-0 pointer-events-none",
            "before:absolute before:top-0 before:inset-x-0",
            "before:h-[min(40px,var(--scroll-area-overflow-y-start,0px))]",
            "before:bg-linear-to-b before:from-black/20 before:to-transparent",
            "after:absolute after:bottom-0 after:inset-x-0",
            "after:h-[min(40px,var(--scroll-area-overflow-y-end,0px))]",
            "after:bg-linear-to-t after:from-black/20 after:to-transparent"
          )}
          style={
            {
              "--scroll-area-overflow-y-start": "inherit",
              "--scroll-area-overflow-y-end": "inherit",
            } as React.CSSProperties
          }
        />
      )}

      {/* Horizontal shadows */}
      {showHorizontal && (
        <div
          className={cn(
            "absolute inset-0 pointer-events-none",
            "before:absolute before:left-0 before:inset-y-0",
            "before:w-[min(40px,var(--scroll-area-overflow-x-start,0px))]",
            "before:bg-linear-to-r before:from-black/20 before:to-transparent",
            "after:absolute after:right-0 after:inset-y-0",
            "after:w-[min(40px,var(--scroll-area-overflow-x-end,0px))]",
            "after:bg-linear-to-l after:from-black/20 after:to-transparent"
          )}
          style={
            {
              "--scroll-area-overflow-x-start": "inherit",
              "--scroll-area-overflow-x-end": "inherit",
            } as React.CSSProperties
          }
        />
      )}

      <ScrollAreaPrimitive.Scrollbar orientation="vertical">
        <ScrollAreaPrimitive.Thumb />
      </ScrollAreaPrimitive.Scrollbar>
    </ScrollAreaPrimitive.Root>
  );
}
```

## Conclusion

We've built scroll shadows using Base UI's CSS custom properties instead of Framer Motion's JavaScript animations. The approach is simpler — shadow visibility is controlled entirely by CSS `min()` — but trades away the smooth proportional fading of Part 1.

Both approaches have their place. If you're already using one of these libraries, stick with it. If you're starting fresh and want the most polished result, Part 1's opacity-based approach edges ahead. But for simpler use cases where "shadow appears when scrollable" is enough, this CSS-driven approach is a clean solution.

## Resources

- [Base UI ScrollArea](https://base-ui.com/react/components/scroll-area) — Official documentation
- [CSS min() function](https://developer.mozilla.org/en-US/docs/Web/CSS/min) — MDN reference
- [Part 1: Scroll Shadows](/crafts/scroll-shadows) — The Framer Motion approach
