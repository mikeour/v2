import { Alert } from "~/components/crafts/alert";
import { ComparisonTable } from "~/components/crafts/comparison-table";
import { Demo } from "~/components/crafts/demo";
import * as ScrollShadowsDemo from "./demos/scroll-shadows/demo";
import * as ProgressDemo from "./demos/progress/demo";
import * as HorizontalDemo from "./demos/horizontal/demo";
import * as ComparisonDemo from "./demos/comparison/demo";

export const metadata = {
  title: "Scroll Shadows (Pt. 2)",
  date: "December 10, 2025",
};

# Scroll Shadows (Pt. 2)

<time className="-mt-6 mb-8 block text-gray-400">December 10, 2025</time>

In [Part 1](/crafts/scroll-shadows), we built scroll shadows using Framer Motion. The library gave us `useScroll` to track scroll position and `MotionValue` to animate opacity outside React's render cycle.

But Framer Motion adds ~30kb to your bundle. What if we could achieve the same effect with just a small hook and CSS?

<Demo
  demo={ScrollShadowsDemo}
  caption="Scroll the content and toggle shadows to see the effect."
  controls={[
    { type: "switch", name: "shadows", label: "Shadows", defaultValue: true },
  ]}
  path="app/crafts/scroll-shadows-pt-2/demos/scroll-shadows"
  files={["demo.tsx", "use-scroll-progress.ts", "scroll-shadows.tsx"]}
/>

## The Goal

We want to replicate Part 1's behavior exactly:

1. Track scroll position as a value from `0` (top) to `1` (bottom)
2. Use that value to control shadow opacity
3. Keep animations smooth (no React re-renders on scroll)

The key insight: CSS custom properties update without triggering React renders. If we set `--scroll-progress` on every scroll event, CSS can use it directly for opacity — no animation library needed.

## Tracking Scroll Progress

In Part 1, Framer Motion's `useScroll` gave us `scrollYProgress` — a value from `0` to `1`. Let's compute that ourselves:

```tsx
const progress =
  element.scrollTop / (element.scrollHeight - element.clientHeight);
```

- `scrollTop` — how far we've scrolled from the top
- `scrollHeight - clientHeight` — the maximum scrollable distance

Dividing gives us a normalized `0` to `1` value, just like Framer Motion.

<Demo
  demo={ProgressDemo}
  caption="Scroll to see the progress value update in real-time."
  inspector={[
    { name: "progress", label: "--scroll-progress", prop: "onProgressChange", format: "decimal", defaultValue: "0.00" },
  ]}
  path="app/crafts/scroll-shadows-pt-2/demos/progress"
/>

## Building the Hook

Here's a hook that tracks scroll progress and exposes it as a CSS custom property:

```tsx
import { useEffect, useRef } from "react";

export function useScrollProgress<T extends HTMLElement = HTMLDivElement>() {
  const ref = useRef<T>(null);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    function updateProgress() {
      if (!element) return;
      const maxScroll = element.scrollHeight - element.clientHeight;
      const progress = maxScroll > 0 ? element.scrollTop / maxScroll : 0;
      element.style.setProperty("--scroll-progress", String(progress));
    }

    updateProgress();
    element.addEventListener("scroll", updateProgress, { passive: true });
    return () => element.removeEventListener("scroll", updateProgress);
  }, []);

  return ref;
}
```

The hook creates and returns a ref — just attach it to your scroll container. The `{ passive: true }` option tells the browser we won't call `preventDefault()`, allowing it to optimize scroll performance.

<Alert variant="note">
  We're setting the CSS variable on the scroll container itself. This means
  child elements can access it via `var(--scroll-progress)` without any
  inheritance issues.
</Alert>

## A Note on Performance

CSS custom properties inherit to all children by default. In complex scroll areas with deep DOM trees, this can trigger style recalculations across the entire subtree — what Matt Perry calls ["the inheritance bomb"](https://motion.dev/blog/web-animation-performance-tier-list).

You can prevent this with `CSS.registerProperty({ inherits: false })`, which is what Base UI does. However, this means child elements can't access the variable unless you explicitly pass it down.

For our simple use case (shadows are direct children), inheritance is actually what we want — the shadow elements need to read `--scroll-progress` from their parent. The performance impact is negligible since we're only affecting a few elements.

<Alert variant="note">
  We're animating `opacity`, which is one of the compositor-friendly properties
  (along with `transform`, `filter`, and `clip-path`). These can be
  hardware-accelerated and skip the browser's layout and paint steps entirely.
</Alert>

## Controlling Shadow Opacity

Now we need to convert `--scroll-progress` into opacity values for each shadow:

- **Start shadow** (top): opacity should equal progress — `0` at top, `1` when scrolled
- **End shadow** (bottom): opacity should be inverse — `1` at top, `0` at bottom

CSS `calc()` makes this easy:

```css
/* Start shadow: opacity = progress */
opacity: var(--scroll-progress, 0);

/* End shadow: opacity = 1 - progress */
opacity: calc(1 - var(--scroll-progress, 1));
```

The fallback values (`0` and `1`) handle the initial render before JavaScript runs.

## The Component

Putting it together:

```tsx
"use client";

import { cn } from "./utils";
import { useScrollProgress } from "./use-scroll-progress";

export function ScrollShadows({
  className,
  children,
}: React.PropsWithChildren<{ className?: string }>) {
  const ref = useScrollProgress();

  return (
    <div ref={ref} className={cn("relative overflow-y-auto", className)}>
      {/* Start shadow */}
      <div
        className="pointer-events-none sticky top-0 -mb-10 h-10 bg-linear-to-b from-black/15 to-transparent"
        style={{ opacity: "var(--scroll-progress, 0)" }}
      />

      {children}

      {/* End shadow */}
      <div
        className="pointer-events-none sticky bottom-0 -mt-10 h-10 bg-linear-to-t from-black/15 to-transparent"
        style={{ opacity: "calc(1 - var(--scroll-progress, 1))" }}
      />
    </div>
  );
}
```

We're using the same sticky positioning trick from Part 1 — shadows stay fixed at the edges while content scrolls beneath them. The negative margins (`-mb-10`, `-mt-10`) prevent the shadows from taking up space in the document flow.

## Handling Edge Cases

What happens when content doesn't overflow? In Part 1, we had to detect this and hide shadows. Here, it's automatic:

- If `scrollHeight === clientHeight`, then `maxScroll` is `0`
- We return `0` for progress, so start shadow has `opacity: 0`
- End shadow has `opacity: calc(1 - 0) = 1`... wait, that's wrong!

We need to handle non-overflowing containers:

```tsx
function updateProgress() {
  if (!element) return;
  const maxScroll = element.scrollHeight - element.clientHeight;

  if (maxScroll <= 0) {
    // No overflow — hide both shadows
    element.style.setProperty("--scroll-progress", "0");
    element.style.setProperty("--has-overflow", "0");
  } else {
    const progress = element.scrollTop / maxScroll;
    element.style.setProperty("--scroll-progress", String(progress));
    element.style.setProperty("--has-overflow", "1");
  }
}
```

Then in CSS, multiply by `--has-overflow`:

```css
/* End shadow: only visible when there's overflow */
opacity: calc((1 - var(--scroll-progress, 1)) * var(--has-overflow, 0));
```

## Horizontal Scrolling

The same pattern works for horizontal scrolling — just swap the axes:

<Demo
  demo={HorizontalDemo}
  caption="Horizontal scroll shadows using the same technique."
  controls={[
    { type: "switch", name: "shadows", label: "Shadows", defaultValue: true },
  ]}
  path="app/crafts/scroll-shadows-pt-2/demos/horizontal"
  files={["demo.tsx"]}
/>

```tsx
export function useScrollProgress<T extends HTMLElement = HTMLDivElement>(
  axis: "x" | "y" = "y"
) {
  const ref = useRef<T>(null);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    function updateProgress() {
      if (!element) return;

      const [scrollPos, scrollSize, clientSize] =
        axis === "y"
          ? [element.scrollTop, element.scrollHeight, element.clientHeight]
          : [element.scrollLeft, element.scrollWidth, element.clientWidth];

      const maxScroll = scrollSize - clientSize;
      const hasOverflow = maxScroll > 0;
      const progress = hasOverflow ? scrollPos / maxScroll : 0;

      element.style.setProperty("--scroll-progress", String(progress));
      element.style.setProperty("--has-overflow", hasOverflow ? "1" : "0");
    }

    updateProgress();
    element.addEventListener("scroll", updateProgress, { passive: true });
    return () => element.removeEventListener("scroll", updateProgress);
  }, [axis]);

  return ref;
}
```

## Comparing the Approaches

<Demo
  demo={ComparisonDemo}
  caption="Both approaches animate opacity — the visual result is identical."
  path="app/crafts/scroll-shadows-pt-2/demos/comparison"
  files={["demo.tsx", "framer-motion.tsx", "css-variables.tsx"]}
/>

<ComparisonTable
  headers={["Part 1 (Framer Motion)", "Part 2 (CSS Variables)"]}
  rows={[
    ["~30kb dependency", "~0kb (just a hook)"],
    ["MotionValue for opacity", "CSS variable for opacity"],
    ["useTransform for derived values", "CSS calc() for derived values"],
    ["Works outside React render", "Works outside React render"],
  ]}
/>

Both approaches animate the same property (`opacity`) using hardware-accelerated compositing. The visual result is identical — we've just swapped the mechanism for tracking and applying the value.

## Handling Resize

One edge case: if the container resizes, our overflow detection might become stale. Let's add a ResizeObserver:

```tsx
useEffect(() => {
  const element = ref.current;
  if (!element) return;

  function updateProgress() {
    /* ... */
  }

  updateProgress();
  element.addEventListener("scroll", updateProgress, { passive: true });

  const resizeObserver = new ResizeObserver(updateProgress);
  resizeObserver.observe(element);

  return () => {
    element.removeEventListener("scroll", updateProgress);
    resizeObserver.disconnect();
  };
}, [ref, axis]);
```

## Going Further

If you need more scroll area features — custom scrollbars, bidirectional scrolling, or better accessibility — check out [Base UI's ScrollArea](https://base-ui.com/react/components/scroll-area). It uses the same CSS variable approach internally and adds:

- Cross-browser custom scrollbars
- `data-*` attributes for overflow state
- Corner handling for bidirectional scroll
- Performance optimizations with `CSS.registerProperty()`

## Final Code

<CodeWithTabs>

```tsx !!tabs scroll-shadows.tsx
"use client";

import { cn } from "./utils";
import { useScrollProgress } from "./use-scroll-progress";

type Axis = "x" | "y";

export function ScrollShadows({
  axis = "y",
  className,
  children,
}: React.PropsWithChildren<{
  axis?: Axis;
  className?: string;
}>) {
  const ref = useScrollProgress(axis);
  const isVertical = axis === "y";

  return (
    <div
      ref={ref}
      className={cn(
        "relative",
        isVertical ? "overflow-y-auto" : "overflow-x-auto",
        className
      )}
    >
      <div
        className={cn(
          "pointer-events-none sticky from-black/15 to-transparent",
          isVertical
            ? "top-0 -mb-10 h-10 bg-linear-to-b"
            : "left-0 -mr-10 h-full w-10 bg-linear-to-r"
        )}
        style={{ opacity: "var(--scroll-progress, 0)" }}
      />
      {children}
      <div
        className={cn(
          "pointer-events-none sticky from-black/15 to-transparent",
          isVertical
            ? "bottom-0 -mt-10 h-10 bg-linear-to-t"
            : "right-0 -ml-10 h-full w-10 bg-linear-to-l"
        )}
        style={{
          opacity:
            "calc((1 - var(--scroll-progress, 1)) * var(--has-overflow, 0))",
        }}
      />
    </div>
  );
}
```

```tsx !!tabs use-scroll-progress.ts
"use client";

import { useEffect, useRef } from "react";

type Axis = "x" | "y";

export function useScrollProgress<T extends HTMLElement = HTMLDivElement>(
  axis: Axis = "y"
) {
  const ref = useRef<T>(null);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    function updateProgress() {
      if (!element) return;

      const [scrollPos, scrollSize, clientSize] =
        axis === "y"
          ? [element.scrollTop, element.scrollHeight, element.clientHeight]
          : [element.scrollLeft, element.scrollWidth, element.clientWidth];

      const maxScroll = scrollSize - clientSize;
      const hasOverflow = maxScroll > 0;
      const progress = hasOverflow ? scrollPos / maxScroll : 0;

      element.style.setProperty("--scroll-progress", String(progress));
      element.style.setProperty("--has-overflow", hasOverflow ? "1" : "0");
    }

    updateProgress();
    element.addEventListener("scroll", updateProgress, { passive: true });

    const resizeObserver = new ResizeObserver(updateProgress);
    resizeObserver.observe(element);

    return () => {
      element.removeEventListener("scroll", updateProgress);
      resizeObserver.disconnect();
    };
  }, [axis]);

  return ref;
}
```

</CodeWithTabs>

## Conclusion

We've replicated Part 1's scroll shadows without Framer Motion:

1. Compute scroll progress (0→1) on each scroll event
2. Expose it as a CSS custom property
3. Use CSS `calc()` to derive shadow opacities

The result is visually identical — both animate opacity using hardware acceleration. The difference is ~30kb less JavaScript and one fewer dependency.

## Resources

- [CSS Custom Properties](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties) — MDN reference
- [Base UI ScrollArea](https://base-ui.com/react/components/scroll-area) — Full-featured scroll area component
- [Part 1: Scroll Shadows](/crafts/scroll-shadows) — The Framer Motion approach
