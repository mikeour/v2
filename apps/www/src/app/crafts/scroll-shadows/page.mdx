import { Alert } from "~/components/crafts/alert";
import { Demo } from "~/components/crafts/demo";
import * as InteractiveDemo from "./demos/interactive/demo";
import * as ProgressDemo from "./demos/progress/demo";
import * as BrokenProgressOverflowDemo from "./demos/broken-progress-overflow/demo";
import * as BrokenProgressNoOverflowDemo from "./demos/broken-progress-no-overflow/demo";
import * as FixedProgressNoOverflowDemo from "./demos/fixed-progress-no-overflow/demo";
import * as MarkupDemo from "./demos/markup/demo";
import * as CarouselDemo from "./demos/carousel/demo";

export const metadata = {
  title: "Scroll Shadows",
  date: "April 22, 2024",
};

# Scroll Shadows

<time className="-mt-6 mb-8 block text-gray-400">April 22, 2024</time>

Scroll shadows are a visual cue that indicates more content exists beyond the visible area. They fade in as you scroll away from an edge and fade out as you approach it.

<Demo
  demo={InteractiveDemo}
  caption="Scroll the article — notice how shadows appear and disappear at the edges."
  controls={[{ type: "switch", name: "shadows", label: "Shadows", defaultValue: true }]}
  path="app/crafts/scroll-shadows/demos/interactive"
  mockBrowser
/>

By the end of this post, we'll build a reusable `<ScrollShadows />` component that adds this effect to any scrollable container. The goal is to make it as simple as:

```tsx
<ScrollShadows>
  <ul>
    <li>...</li>
    <li>...</li>
  </ul>
</ScrollShadows>
```

## What We're Building

Before diving in, let's define our acceptance criteria:

- Support both top and bottom shadows (start and end)
- Shadows fade independently based on scroll position
- Gracefully handle containers that don't overflow (no shadows shown)
- Fully customizable via CSS
- Bonus: support horizontal scrolling too

## The Approach

We'll use [Framer Motion](https://www.framer.com/motion/) for two reasons:

1. **`useScroll`** — gives us scroll position as a reactive value
2. **Performance** — tracks values outside React's render cycle, so scroll events don't trigger re-renders (keeping animations smooth at 60fps)

```zsh
npm install framer-motion
```

<Alert variant="note">
  Using an animation library adds bundle size. If that's a concern, check out
  this [pure CSS solution](https://css-scroll-shadows.vercel.app/) first — it's
  limited but lightweight.
</Alert>

The core idea: we need two values to control shadow opacity:

- **`startingShadowVisibility`** — `0` when at the top, `1` when scrolled away
- **`endingShadowVisibility`** — `1` when at the top, `0` when at the bottom

## Tracking Scroll Progress

Framer Motion's `useScroll` hook tracks scroll position as a decimal from `0` (top) to `1` (bottom):

```tsx
const articleRef = useRef(null);
const { scrollYProgress } = useScroll({ container: articleRef });

<article ref={articleRef} className="overflow-y-auto">
  {children}
</article>;
```

<Demo
  demo={ProgressDemo}
  caption="Scroll the article to see the value update in real-time."
  path="app/crafts/scroll-shadows/demos/progress"
  inspector={[{ name: "progress", prop: "onProgressChange", format: "decimal", defaultValue: "0.00" }]}
  mockBrowser
/>

This gives us our starting point. The `scrollYProgress` value already matches what we need for `startingShadowVisibility` — it's `0` at the top and increases as we scroll.

For `endingShadowVisibility`, we need the inverse: `1` at the top, `0` at the bottom. Framer Motion's `useTransform` hook lets us derive one MotionValue from another:

```tsx
const endingShadowVisibility = useTransform(
  scrollYProgress,
  (latest) => 1 - latest
);
```

<Alert variant="note">
  Why `useTransform` instead of just `1 - scrollYProgress`? Because
  `scrollYProgress` is a MotionValue (a reactive container), not a plain number.
  `useTransform` creates a new MotionValue that automatically updates when the
  source changes.
</Alert>

Here's our initial hook:

```tsx
!from ./snippets/added-progress.tsx
```

Let's visualize both values. Toggle the shadows on to see them respond to scroll:

<Demo
  demo={BrokenProgressOverflowDemo}
  path="app/crafts/scroll-shadows/demos/broken-progress-overflow"
  controls={[{ type: "switch", name: "showShadows", label: "Shadows", defaultValue: true }]}
  inspector={[
    { name: "start", prop: "onStartChange", format: "decimal", defaultValue: "0.00" },
    { name: "end", prop: "onEndChange", format: "decimal", defaultValue: "1.00" }
  ]}
  mockBrowser
/>

Looking good! But there's a bug hiding. Let's see what happens when the content doesn't overflow:

## Handling Edge Cases

<Demo
  demo={BrokenProgressNoOverflowDemo}
  caption="Toggle shadows ON — why is the top shadow visible?"
  path="app/crafts/scroll-shadows/demos/broken-progress-no-overflow"
  controls={[{ type: "switch", name: "showShadows", label: "Shadows", defaultValue: true }]}
  inspector={[
    { name: "start", prop: "onStartChange", format: "decimal", defaultValue: "1.00" },
    { name: "end", prop: "onEndChange", format: "decimal", defaultValue: "0.00" }
  ]}
  mockBrowser
/>

When a container doesn't overflow, `useScroll` defaults `scrollYProgress` to `1` (not `0`). This means our starting shadow shows at full opacity even though there's nothing to scroll.

We need to detect non-overflowing containers and force the shadow to hide:

```tsx
const startingShadowVisibility = useTransform(scrollYProgress, (latest) => {
  const element = ref.current;
  if (element === null) return latest;

  const isOverflowing = element.scrollHeight > element.clientHeight;

  if (isOverflowing) {
    return latest; // normal behavior
  } else {
    return 0; // hide shadow when nothing to scroll
  }
});
```

Now both shadows correctly hide when there's no overflow:

<Demo
  demo={FixedProgressNoOverflowDemo}
  path="app/crafts/scroll-shadows/demos/fixed-progress-no-overflow"
  controls={[{ type: "switch", name: "showShadows", label: "Shadows", defaultValue: true }]}
  inspector={[
    { name: "start", prop: "onStartChange", format: "decimal", defaultValue: "0.00" },
    { name: "end", prop: "onEndChange", format: "decimal", defaultValue: "0.00" }
  ]}
  mockBrowser
/>

Here's the complete hook:

```tsx
!from ./snippets/added-modified-progress.tsx
```

## Positioning the Shadows

Now for the visual part. We'll use a clever CSS technique: `position: sticky` with negative margins.

Here's why it works:

- `sticky` elements stay fixed relative to their scroll container
- A negative margin equal to the element's height removes it from document flow
- The shadow overlays the content without pushing it down

```tsx
<div ref={ref} className="relative flex flex-col overflow-y-auto [--size:48px]">
  {/* Top shadow: stuck to top, negative bottom margin */}
  <div className="sticky top-0 -mb-(--size) h-(--size) bg-linear-to-b from-black/20 to-transparent" />

  {children}

  {/* Bottom shadow: stuck to bottom, negative top margin */}
  <div className="sticky bottom-0 -mt-(--size) h-(--size) bg-linear-to-t from-black/20 to-transparent" />
</div>
```

<Demo
  demo={MarkupDemo}
  caption="Drag the slider to see how shadow size affects the layout."
  path="app/crafts/scroll-shadows/demos/markup"
  files={["demo.tsx"]}
  controls={[{ type: "slider", name: "size", label: "Size", min: 16, max: 64, step: 16, defaultValue: 48 }]}
  mockBrowser
/>

<Alert variant="tip">
  I'm using Tailwind with a `cn` helper from
  [shadcn/ui](https://ui.shadcn.com/docs/installation) for conditional classes.
  See the [Vanilla CSS](#vanilla-css) section at the end for a plain CSS
  version.
</Alert>

## Polishing the Effect

The blue overlays are great for debugging, but real scroll shadows should be subtle gradients that blend with your background:

```tsx
// Instead of solid colors:
className = "bg-blue-400/30";

// Use gradients that fade to transparent:
className = "bg-linear-to-b from-white to-transparent"; // top shadow
className = "bg-linear-to-t from-white to-transparent"; // bottom shadow
```

For dark backgrounds, use `from-black/20` or match your background color. The key is subtlety — scroll shadows should guide attention, not demand it.

## Supporting Horizontal Scrolling

Let's extend our implementation to support carousels and horizontal lists.

First, we add an `axis` option to the hook:

```tsx
type AxisType = "x" | "y";

function useScrollShadows({
  ref,
  axis,
}: {
  ref: RefObject<HTMLElement>;
  axis: AxisType;
}) {
  const { scrollXProgress, scrollYProgress } = useScroll({ container: ref });

  const scrollProgress = axis === "x" ? scrollXProgress : scrollYProgress;

  const isOverflowing = (element: HTMLElement) => {
    return axis === "x"
      ? element.scrollWidth > element.clientWidth
      : element.scrollHeight > element.clientHeight;
  };

  // ... rest of hook using scrollProgress and isOverflowing
}
```

Then update the component to position shadows on left/right for horizontal scrolling:

```tsx
<div
  ref={ref}
  data-axis={axis}
  className={cn(
    "group relative flex",
    "data-[axis=x]:flex-row data-[axis=x]:overflow-x-auto",
    "data-[axis=y]:flex-col data-[axis=y]:overflow-y-auto"
  )}
>
  <motion.div
    style={{ opacity: startingShadowVisibility }}
    className={cn(
      "pointer-events-none sticky shrink-0",
      // Horizontal: left edge, full height
      "group-data-[axis=x]:left-0 group-data-[axis=x]:top-0 group-data-[axis=x]:bottom-0 group-data-[axis=x]:w-(--size) group-data-[axis=x]:-mr-(--size)",
      // Vertical: top edge, full width
      "group-data-[axis=y]:top-0 group-data-[axis=y]:h-(--size) group-data-[axis=y]:-mb-(--size)"
    )}
  />
  {children}
  {/* ... end shadow with mirrored positioning */}
</div>
```

Here's horizontal scrolling in action:

<Demo
  demo={CarouselDemo}
  path="app/crafts/scroll-shadows/demos/carousel"
/>

## Final Code

Here's the complete implementation:

### Tailwind

<CodeWithTabs>

```tsx !!tabs scroll-shadows.tsx
import { useRef } from "react";
import { motion } from "framer-motion";
import { cn } from "./utils";
import { useScrollShadows } from "./use-scroll-shadows";

export function ScrollShadows({
  axis = "y",
  className,
  children,
}: React.PropsWithChildren<{
  axis?: "x" | "y";
  className?: string;
}>) {
  const ref = useRef<HTMLDivElement>(null);
  const [start, end] = useScrollShadows({ ref, axis });

  return (
    <div
      ref={ref}
      data-axis={axis}
      className={cn(
        "group relative flex [--size:40px]",
        "data-[axis=x]:flex-row data-[axis=x]:overflow-x-auto",
        "data-[axis=y]:flex-col data-[axis=y]:overflow-y-auto",
        className
      )}
    >
      <motion.div
        style={{ opacity: start }}
        className={cn(
          "pointer-events-none sticky shrink-0 from-black/10 to-transparent",
          "group-data-[axis=x]:left-0 group-data-[axis=x]:top-0 group-data-[axis=x]:bottom-0 group-data-[axis=x]:w-(--size) group-data-[axis=x]:-mr-(--size) group-data-[axis=x]:bg-linear-to-r",
          "group-data-[axis=y]:top-0 group-data-[axis=y]:h-(--size) group-data-[axis=y]:-mb-(--size) group-data-[axis=y]:bg-linear-to-b"
        )}
      />
      {children}
      <motion.div
        style={{ opacity: end }}
        className={cn(
          "pointer-events-none sticky shrink-0 from-black/10 to-transparent",
          "group-data-[axis=x]:right-0 group-data-[axis=x]:top-0 group-data-[axis=x]:bottom-0 group-data-[axis=x]:w-(--size) group-data-[axis=x]:-ml-(--size) group-data-[axis=x]:bg-linear-to-l",
          "group-data-[axis=y]:bottom-0 group-data-[axis=y]:h-(--size) group-data-[axis=y]:-mt-(--size) group-data-[axis=y]:bg-linear-to-t"
        )}
      />
    </div>
  );
}
```

```tsx !!tabs use-scroll-shadows.ts
import { useScroll, useTransform } from "framer-motion";
import type { RefObject } from "react";

type AxisType = "x" | "y";

export function useScrollShadows({
  ref,
  axis = "y",
}: {
  ref: RefObject<HTMLElement | null>;
  axis?: AxisType;
}) {
  const { scrollXProgress, scrollYProgress } = useScroll({ container: ref });

  const scrollProgress = axis === "x" ? scrollXProgress : scrollYProgress;

  const isOverflowing = (element: HTMLElement) => {
    return axis === "x"
      ? element.scrollWidth > element.clientWidth
      : element.scrollHeight > element.clientHeight;
  };

  const startingShadowVisibility = useTransform(scrollProgress, (latest) => {
    const element = ref.current;
    if (element === null) return latest;
    return isOverflowing(element) ? latest : 0;
  });

  const endingShadowVisibility = useTransform(
    scrollProgress,
    (latest) => 1 - latest
  );

  return [startingShadowVisibility, endingShadowVisibility] as const;
}
```

</CodeWithTabs>

### Vanilla CSS

<CodeWithTabs>

```tsx !!tabs scroll-shadows.tsx
import { useRef } from "react";
import { motion } from "framer-motion";
import { useScrollShadows } from "./use-scroll-shadows";
import "./styles.css";

export function ScrollShadows({
  axis = "y",
  className,
  children,
}: React.PropsWithChildren<{
  axis?: "x" | "y";
  className?: string;
}>) {
  const ref = useRef<HTMLDivElement>(null);
  const [start, end] = useScrollShadows({ ref, axis });

  return (
    <div ref={ref} data-axis={axis} className={`scroll-shadows ${className}`}>
      <motion.div style={{ opacity: start }} className="scroll-shadow scroll-shadow-start" />
      {children}
      <motion.div style={{ opacity: end }} className="scroll-shadow scroll-shadow-end" />
    </div>
  );
}
```

```tsx !!tabs use-scroll-shadows.ts
import { useScroll, useTransform } from "framer-motion";
import type { RefObject } from "react";

type AxisType = "x" | "y";

export function useScrollShadows({
  ref,
  axis = "y",
}: {
  ref: RefObject<HTMLElement | null>;
  axis?: AxisType;
}) {
  const { scrollXProgress, scrollYProgress } = useScroll({ container: ref });

  const scrollProgress = axis === "x" ? scrollXProgress : scrollYProgress;

  const isOverflowing = (element: HTMLElement) => {
    return axis === "x"
      ? element.scrollWidth > element.clientWidth
      : element.scrollHeight > element.clientHeight;
  };

  const startingShadowVisibility = useTransform(scrollProgress, (latest) => {
    const element = ref.current;
    if (element === null) return latest;
    return isOverflowing(element) ? latest : 0;
  });

  const endingShadowVisibility = useTransform(
    scrollProgress,
    (latest) => 1 - latest
  );

  return [startingShadowVisibility, endingShadowVisibility] as const;
}
```

```css !!tabs styles.css
.scroll-shadows {
  --size: 40px;
  position: relative;
  display: flex;
}

.scroll-shadows[data-axis="y"] {
  flex-direction: column;
  overflow-y: auto;
}

.scroll-shadows[data-axis="x"] {
  flex-direction: row;
  overflow-x: auto;
}

.scroll-shadow {
  pointer-events: none;
  position: sticky;
  flex-shrink: 0;
}

/* Vertical shadows */
.scroll-shadows[data-axis="y"] .scroll-shadow-start {
  top: 0;
  height: var(--size);
  margin-bottom: calc(var(--size) * -1);
  background: linear-gradient(to bottom, rgba(0, 0, 0, 0.1), transparent);
}

.scroll-shadows[data-axis="y"] .scroll-shadow-end {
  bottom: 0;
  height: var(--size);
  margin-top: calc(var(--size) * -1);
  background: linear-gradient(to top, rgba(0, 0, 0, 0.1), transparent);
}

/* Horizontal shadows */
.scroll-shadows[data-axis="x"] .scroll-shadow-start {
  left: 0;
  top: 0;
  bottom: 0;
  width: var(--size);
  margin-right: calc(var(--size) * -1);
  background: linear-gradient(to right, rgba(0, 0, 0, 0.1), transparent);
}

.scroll-shadows[data-axis="x"] .scroll-shadow-end {
  right: 0;
  top: 0;
  bottom: 0;
  width: var(--size);
  margin-left: calc(var(--size) * -1);
  background: linear-gradient(to left, rgba(0, 0, 0, 0.1), transparent);
}
```

</CodeWithTabs>

## Conclusion

We built a reusable scroll shadow component that:

- Tracks scroll position with Framer Motion's `useScroll`
- Derives shadow visibility with `useTransform`
- Handles edge cases (non-overflowing containers)
- Uses sticky positioning with negative margins for layout
- Supports both vertical and horizontal scrolling

Scroll shadows are a small detail, but they're the kind of polish that makes interfaces feel thoughtful. They guide users without demanding attention — exactly what good UI should do.

<Alert variant="note">
  **Accessibility note:** Scroll shadows are a visual enhancement, not a
  replacement for proper scrollable region semantics. Screen reader users won't
  perceive them, so ensure your scrollable areas are properly labeled with
  `role` and `aria-label` attributes when appropriate.
</Alert>

## Resources

- [Adding Elegant Shadows with React](https://www.qovery.com/blog/adding-elegant-shadows-with-react-to-invite-users-to-scroll/) — the article that inspired the sticky positioning technique
- [CSS Scroll Shadows Generator](https://css-scroll-shadows.vercel.app/) — pure CSS alternative
- [Framer Motion Documentation](https://www.framer.com/motion/) — for `useScroll` and `useTransform`
